#!/usr/bin/tclsh

package require solv
package require inifile
package require fileutil

set reposdir /etc/zypp/repos.d

proc fileno {file} {
  if [regexp -- {^file(\d+)$} $file match fd] {
    return $fd
  }
  error "file not open"
}

### generic repo handling (cache reading/writing)

proc repo_calc_cookie_file {selfName filename} {
  upvar $selfName self
  set chksum [solv::new_Chksum $solv::REPOKEY_TYPE_SHA256]
  $chksum add "1.1"
  $chksum add_stat $filename
  return [$chksum raw]
}

proc repo_calc_cookie_fp {selfName fp} {
  upvar $selfName self
  set chksum [solv::new_Chksum $solv::REPOKEY_TYPE_SHA256]
  $chksum add 1.1
  $chksum add_fp $fp
  return [$chksum raw]
}

proc repo_calc_cookie_ext {selfName f cookie} {
  upvar $selfName self
  set chksum [solv::new_Chksum $solv::REPOKEY_TYPE_SHA256]
  $chksum add 1.1
  $chksum add $cookie
  $chksum add_fstat [$f fileno]
  set extcookie [$chksum raw]
  if {[string index $extcookie 0] eq "\000"} {
    set extcookie [string replace $extcookie 0 0 "\001"]
  }
  return $extcookie
}

proc repo_cachepath {selfName {ext "-"}} {
  upvar $selfName self
  regsub {^\.} $self(name) _ path
  if {$ext ne "-"} {
    set path "${path}_$ext.solvx"
  } else {
    set path "${path}.solv"
  }
  regsub -all / $path _ path
  return "/var/cache/solv/$path"
}

proc repo_generic_load {selfName pool} {
  upvar $selfName self
  set handle [ $pool add_repo $self(name) ]
  set self(handle) $handle
  $handle configure -priority [expr 99 - $self(priority)]
  upvar self "::repo_appdata_$handle"
  set dorefresh $self(autorefresh)
  set metadata_expire $self(metadata_expire)
  catch {
    if {$metadata_expire == -1 || [clock seconds] - [file mtime [repo_cachepath self]] < $metadata_expire} {
      set dorefresh 0
    }
  }
  set self(cookie) {}
  if { !$dorefresh && [repo_usecachedrepo self] } {
    puts "repo $self(name): cached"
    return 1 
  }
  return 0 
}

proc repo_free_handle {selfName} {
  upvar $selfName self
  set handle $self(handle)
  set ::repo_appdata_gone 1
  upvar ::repo_appdata_gone "::repo_appdata_$handle"
  unset "::repo_appdata_$handle"
  unset self(handle)
  $handle free 1
}

proc repo_usecachedrepo {selfName {ext "-"} {mark 0}} {
  upvar $selfName self
  set repopath [repo_cachepath self]
  set code [catch {
    set f [open $repopath "rb"]
    seek $f -32 end
    set fcookie [read $f 32]
    set cookie [expr {$ext eq "-" ? $self(cookie) : $self(extcookie)}]
    if {$cookie ne {} && $cookie ne $fcookie} {
      close $f
      return 0
    }
    set fextcookie {}
    if {$ext eq "-" && $self(type) ne "system"} {
      seek $f -64 end
      set fextcookie [read $f 32]
    }
    seek $f 0 start
    set ff [solv::xfopen_fd {} [fileno $f]]
    close $f
    set flags 0
    if {$ext ne "-"} {
      set flags [expr $solv::Repo_REPO_USE_LOADING | $solv::Repo_REPO_EXTEND_SOLVABLES]
      if {$ext ne "DL"} {
	set flags [expr $flags | $solv::Repo_REPO_LOCALPOOL]
      }
    }
    if {! [$self(handle) add_solv $ff $flags]} {
      $ff close
      return 0
    }
    $ff close
    if {$self(type) ne "system" && $ext eq "-"} {
      set self(cookie) $fcookie
      set self(extcookie) $fextcookie
    }
    if {$mark} {
      catch {
        ::fileutil::touch -c -m -t [clock seconds] $repopath
      }
    }
    return 1
  } res]
  return [expr {$code == 2 ? $res : 0}]
}

proc repo_writecachedrepo {selfName {ext "-"} {info "NULL"}} {
  upvar $selfName self
  if [info exists self(incomplete)] {
    return
  }
  file mkdir "/var/cache/solv"
  ::fileutil::tempdir "/var/cache/solv"
  set tempfilename [::fileutil::tempfile ".newsolv-"]
  ::fileutil::tempdirReset
  set f [solv::xfopen $tempfilename "w+"]
  file attributes $tempfilename -permissions 0444
  if {$info eq {NULL}} {
    $self(handle) write $f
  } else {
    $info write $f
  }
  $f flush
  if {$self(type) ne "system" && $ext eq "-"} {
    if {![info exists self(extcookie)]} {
      set self(extcookie) [repo_calc_cookie_ext self $f $self(cookie)]
    }
    $f write $self(extcookie)
  }
  $f write [expr {$ext eq "-" ? $self(cookie) : $self(extcookie)}]
  $f close
  file rename -force -- $tempfilename [repo_cachepath self $ext]
}

proc repo_download {selfName file uncompress chksum {markincomplete 0}} {
  upvar $selfName self
  regsub {/$} $self(baseurl) {} url
  set url "$url/$file"
  set tempfilename [::fileutil::tempfile]
  set f [open $tempfilename rb+]
  file delete -- $tempfilename
  if [catch {
    exec -ignorestderr -- curl -f -s -L $url ">@$f"
  }] {
    seek $f 0 end
    if {($chksum ne "" && $chksum ne "NULL") || [tell $f] != 0} {
      puts "$file: download error"
    }
    close $f
    return {NULL}
  }
  seek $f 0 start
  if {$chksum ne "" && $chksum ne "NULL"} {
    set fchksum [solv::new_Chksum [$chksum cget -type]]
    if {$fchksum eq "" || $fchksum eq "NULL"} {
      puts "$file: unknown checksum type"
      if {$markincomplete} {
	set self(incomplete) 1
      }
      close $f
      return {NULL}
    }
    $fchksum add_fd [fileno $f]
    if {[$fchksum hex] ne [$chksum hex]} {
      puts "$file: checksum mismatch"
      if {$markincomplete} {
	set self(incomplete) 1
      }
      close $f
      return {NULL}
    }
  }
  set ff [solv::xfopen_fd [expr {$uncompress ? $file : ""}] [fileno $f]]
  close $f
  return $ff
}

### system

proc repo_system_load {selfName pool} {
  upvar $selfName self
  set handle [ $pool add_repo $self(name) ]
  set self(handle) $handle
  upvar self "::repo_appdata_$handle"
  $pool configure -installed $handle
  puts -nonewline "rpm database: "
  set self(cookie) [repo_calc_cookie_file self "/var/lib/rpm/Packages"]
  if [repo_usecachedrepo self] {
    puts "cached"
    return 1
  }
  puts "reading"
  set f [solv::xfopen [repo_cachepath self]]
  $handle add_rpmdb_reffp $f $solv::Repo_REPO_REUSE_REPODATA
  repo_writecachedrepo self
}

### repomd

proc repo_repomd_find {selfName what} {
  upvar $selfName self
  set di [$self(handle) Dataiterator_meta $solv::REPOSITORY_REPOMD_TYPE $what $solv::Dataiterator_SEARCH_STRING]
  $di prepend_keyname $solv::REPOSITORY_REPOMD
  solv::iter d $di {
    set dp [$d parentpos]
    set filename [$dp lookup_str $solv::REPOSITORY_REPOMD_LOCATION]
    set checksum [$dp lookup_checksum $solv::REPOSITORY_REPOMD_CHECKSUM]
    if {$filename ne "" && $checksum eq "NULL"} {
      puts "no $filename file checksum"
    } elseif {$filename ne ""} {
      return [list $filename $checksum]
    }
  }
  return {}
}

proc repo_repomd_load {selfName pool} {
  upvar $selfName self
  if [repo_generic_load self $pool] {
    return 1
  }
  puts -nonewline "rpmmd repo '$self(name)': "
  set f [repo_download self {repodata/repomd.xml} 0 {}]
  if {$f eq {NULL}} {
    puts "no repomd.xml file, skipped"
    repo_free_handle self
    return 0
  }
  set self(cookie) [repo_calc_cookie_fp self $f]
  if [repo_usecachedrepo self] {
    puts "cached"
    return 1
  }
  set handle $self(handle)
  $handle add_repomdxml $f
  puts "fetching"
  set primary [repo_repomd_find self primary]
  if {$primary ne {}} {
    set f [repo_download self [lindex $primary 0] 1 [lindex $primary 1] 1]
    if {$f ne {NULL}} {
      $handle add_rpmmd $f {NULL}
      $f close
    }
    if [info exists self(incomplete)] {
      return 0
    }
  }
  set updateinfo [repo_repomd_find self primary]
  if {$updateinfo ne {}} {
    set f [repo_download self [lindex $updateinfo  0] 1 [lindex $updateinfo 1] 1]
    if {$f ne {NULL}} {
      $handle add_updateinfoxml $f
      $f close
    }
  }
  repo_writecachedrepo self
  return 1
}

### susetags

proc repo_susetags_find {selfName what} {
  upvar $selfName self
  set di [$self(handle) Dataiterator_meta $solv::SUSETAGS_FILE_NAME $what $solv::Dataiterator_SEARCH_STRING]
  $di prepend_keyname $solv::SUSETAGS_FILE
  solv::iter d $di {
    set dp [$d parentpos]
    set checksum [$dp lookup_checksum $solv::SUSETAGS_FILE_CHECKSUM]
    return [list $what $checksum]
  }
  return {}
}

proc repo_susetags_load {selfName pool} {
  upvar $selfName self
  if [repo_generic_load self $pool] {
    return 1
  }
  puts -nonewline "susetags repo '$self(name)': "
  set f [repo_download self {content} 0 {}]
  if {$f eq {NULL}} {
    puts "no content file, skipped"
    repo_free_handle self
    return 0
  }
  set self(cookie) [repo_calc_cookie_fp self $f]
  if [repo_usecachedrepo self] {
    puts "cached"
    return 1
  }
  set handle $self(handle)
  $handle add_content $f
  puts "fetching"
  set defvendorid [[$handle cget -meta] lookup_id $solv::SUSETAGS_DEFAULTVENDOR]
  set descrdir [[$handle cget -meta] lookup_str $solv::SUSETAGS_DESCRDIR]
  if {$descrdir eq {NULL}} {
    set descrdir "suse/setup/descr"
  }
  set packages [repo_susetags_find self "packages.gz"]
  if {$packages eq {}} {
    set packages [repo_susetags_find self "packages"]
  }
  if {$packages ne {}} {
    set f [repo_download self "$descrdir/[lindex $packages 0]" 1 [lindex $packages 1] 1]
    if {$f ne {NULL}} {
      $handle add_susetags $f $defvendorid {} [expr $solv::Repo_REPO_NO_INTERNALIZE | $solv::Repo_SUSETAGS_RECORD_SHARES]
      $f close
      set packages [repo_susetags_find self "packages.en.gz"]
      if {$packages eq {}} {
	set packages [repo_susetags_find self "packages.en"]
      }
      if {$packages ne {}} {
	set f [repo_download self "$descrdir/[lindex $packages 0]" 1 [lindex $packages 1] 1]
	if {$f ne {NULL}} {
          $handle add_susetags $f $defvendorid {} [expr $solv::Repo_REPO_NO_INTERNALIZE | $solv::Repo_REPO_REUSE_REPODATA | $solv::Repo_REPO_EXTEND_SOLVABLES ]
	  $f close
	}
      }
      $handle internalize
    }
  }
  repo_writecachedrepo self
  return 1
}

### unknown

proc repo_unknown_load {selfName pool} {
  upvar $selfName self
  puts "unsupported repo '$self(name)': skipped"
  return 0
}

### poor man's OO

proc repo_load {selfName pool} {
  upvar $selfName self
  "repo_$self(type)_load" self $pool
}

###

set repoNames {}
foreach reponame [lsort [glob -nocomplain -directory $reposdir *.repo]] {
  set ini [::ini::open $reponame r]
  foreach alias [::ini::sections $ini] {
    set num [llength $repoNames]
    array set "repos$num" {}
    upvar 0 "repos$num" repoattr
    array set repoattr {enabled 0 priority 99 autorefresh 1 type rpm-md metadata_expire 900}
    array set repoattr [::ini::get $ini $alias]
    set repoattr(name) $alias
    switch -exact -- $repoattr(type) {
      rpm-md  { set repoattr(type) repomd }
      yast2   { set repoattr(type) susetags }
      default { set repoattr(type) unknown }
    }
    lappend repoNames "repos$num" 
  }
  ::ini::close $ini
}

set pool [solv::new_Pool]
$pool setarch

array set sysrepo [list name {@System} type system]
repo_load sysrepo $pool

foreach repoName $repoNames {
  upvar 0 $repoName repo
  if {$repo(enabled)} {
    repo_load repo $pool
  }
}


set cmd [lindex $::argv 0]

if {$cmd == "search"} {
  set arg [lindex $::argv 1]
  $pool createwhatprovides
  set sel [$pool Selection]
  set di [$pool Dataiterator $solv::SOLVABLE_NAME $arg [ expr $solv::Dataiterator_SEARCH_SUBSTRING | $solv::Dataiterator_SEARCH_NOCASE ]]
  solv::iter d $di {
    $sel add_raw $solv::Job_SOLVER_SOLVABLE [$d cget -solvid]
  }
  foreach s [$sel solvables] {
    puts [format { - %s [%s]: %s} [$s __str__] [[$s cget -repo] cget -name] [$s lookup_str $solv::SOLVABLE_SUMMARY]]
  }
  exit
}

